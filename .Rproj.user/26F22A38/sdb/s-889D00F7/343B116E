{
    "collab_server" : "",
    "contents" : "shinyServer(function(input, output, session) {\n\n  ### Authentication Functions ########################################################\n  ##\n  ##   AuthCode() - checks for presence of code in URL\n  ##   AccessToken() - creates a token once a code is available\n  ##   ShinyMakeGAProfileTable - the table of profiles taken from API\n  ##   output$AuthGAURL - creates the authentication URL\n  ##   output$GAProfile - table of the profiles belonging to user\n\n  AuthCode  <- reactive({\n\n    ## gets all the parameters in the URL. Your authentication code should be one of them\n    pars <- parseQueryString(session$clientData$url_search)\n\n    if(length(pars$code) > 0){\n      return(pars$code)\n    }\n  })\n\n  AccessToken <- reactive({\n    validate(\n      need(AuthCode(), \"Authenticate To See\")\n    )\n    access_token <- ShinyGetToken(code = AuthCode())\n\n    access_token$access_token\n  })\n\n  output$AuthGAURL <- renderUI({\n    a(\"Click to Authorise Spotify Access\", href=ShinyGetTokenURL())\n  })\n\n  ShinyMakeGAProfileTable <- reactive({\n\n    token <- AccessToken()\n  })\n\n  genres <- reactive({\n    resp <- GET(\"https://api.spotify.com/v1/recommendations/available-genre-seeds\",\n                add_headers(Authorization = sprintf(\"Bearer %s\", ShinyMakeGAProfileTable())))\n    content(resp)$genres\n  })\n\n  categories <- reactive({\n\n  })\n\n  output$genres <- renderUI({\n    selectInput(\"genres\", \"Genre\", c = genres())\n  })\n\n  me <- reactive({\n    req(ShinyMakeGAProfileTable())\n    GET(\"https://api.spotify.com/v1/me\",\n        add_headers(Authorization = sprintf(\"Bearer %s\", ShinyMakeGAProfileTable())))\n  })\n\n  # browse.new.releases <- reactive({\n  #   req(ShinyMakeGAProfileTable())\n  #   GET(\"https://api.spotify.com/v1/browse/new-releases\",\n  #       add_headers(Authorization = \"Bearer %s\"))\n  # })\n\n  output$token <- renderText({\n    ShinyMakeGAProfileTable()\n  })\n\n  output$new_releases <- renderDataTable({\n    resp <- GET(sprintf(\"https://api.spotify.com/v1/browse/new-releases?limit=%s\", input$nr.limit),\n                add_headers(Authorization = sprintf(\"Bearer %s\", ShinyMakeGAProfileTable())))\n    c <- content(resp)\n    data <- data.frame(artist = sapply(1:length(c$albums$items), function(x) c$albums$items[[x]]$artists[[1]]$name),\n                       album = sapply(1:length(c$albums$items), function(x) c$albums$items[[x]]$name))\n    datatable(data)\n  })\n\n  output$stonesthrow.catalog <- renderDataTable({\n    datatable(stonesthrow)\n  })\n\n  output$playlists <- renderDataTable({\n    resp <- GET(\"https://api.spotify.com/v1/me/playlists\",\n                add_headers(Authorization = sprintf(\"Bearer %s\", ShinyMakeGAProfileTable())))\n    c <- content(resp)\n    data <- data.frame(playlist = sapply(1:length(c$items), function(x) c$items[[x]]$name),\n                       tracks = sapply(1:length(c$items), function(x) c$items[[x]]$tracks$total),\n                       href = sapply(1:length(c$items), function(x) c$items[[x]]$href))\n    datatable(data)\n  })\n\n  # append_criteria <- function(item) {\n  #   if(input[[item]] == TRUE) {\n  #     url <<- paste0(url, sprintf(\"&min_%s=%s\", name, input[[name]]), collapse = \"\")\n  #   }\n  # }\n\n  recommendation <- reactive({\n    url <- \"https://api.spotify.com/v1/recommendations?seed_artists=4NHQUGzhtTLFvgF5SZesLK\"\n    if (input$energy_on == TRUE) {\n      url <- paste0(url, sprintf(\"&%s_energy=%s\", input$energy_mode, input$energy), collapse = \"\")\n    }\n    url\n  })\n\n  output$recommendations <- renderDataTable({\n    # append_criteria(\"energy\")\n    # if(input$energy == TRUE) {\n    #   paste0(url, sprintf(\"&min_energy=%s\", input$energy), collapse = \"\")\n    # }\n    # if(input$energy == TRUE) {\n    #   paste0(url, sprintf(\"&min_energy=%s\", input$energy), collapse = \"\")\n    # }\n    # if(input$energy == TRUE) {\n    #   paste0(url, sprintf(\"&min_energy=%s\", input$energy), collapse = \"\")\n    # }\n    # if(input$energy == TRUE) {\n    #   paste0(url, sprintf(\"&min_energy=%s\", input$energy), collapse = \"\")\n    # }\n    # if(input$energy == TRUE) {\n    #   paste0(url, sprintf(\"&min_energy=%s\", input$energy), collapse = \"\")\n    # }\n\n    resp <- GET(recommendation(),\n                add_headers(Authorization = sprintf(\"Bearer %s\", ShinyMakeGAProfileTable())))\n    c <- content(resp)\n    recs <- data.frame(track = sapply(c$tracks, function(x) x$name),\n                       artist = sapply(c$tracks, function(x) x$artists[[1]]$name))\n    datatable(recs)\n  })\n\n})\n  ## end server.r\n\n# METHOD\tENDPOINT\tUSAGE\tRETURNS\tOAUTH\n# GET\n# /v1/albums/{id}\tGet an album\talbum\tOAuth\n# GET\t/v1/albums?ids={ids}\n# Get several albums\talbums\tOAuth\n# GET\t/v1/albums/{id}/tracks\tGet an album's tracks\ttracks*\tOAuth\n# GET\n# /v1/artists/{id}\n# Get an artist\tartist\tOAuth\n# GET\n# /v1/artists?ids={ids}\n# Get several artists\tartists\tOAuth\n# GET\t/v1/artists/{id}/albums\tGet an artist's albums\talbums*\tOAuth\n# GET\t/v1/artists/{id}/top-tracks\tGet an artist's top tracks\ttracks\tOAuth\n# GET\t/v1/artists/{id}/related-artists\tGet an artist's related artists\tartists\tOAuth\n# GET\tv1/audio-analysis/{id}\tGet Audio Analysis for a Track\taudio analysis object\tOAuth\n# GET\t/v1/audio-features/{id}\tGet audio features for a track\taudio features\tOAuth\n# GET\t/v1/audio-features?ids={ids}\tGet audio features for several tracks\taudio features\tOAuth\n# GET\t/v1/browse/featured-playlists\tGet a list of featured playlists\tplaylists\tOAuth\n# GET\t/v1/browse/new-releases\tGet a list of new releases\talbums*\tOAuth\n# GET\t/v1/browse/categories\tGet a list of categories\tcategories\tOAuth\n# GET\t/v1/browse/categories/{id}\tGet a category\tcategory\tOAuth\n# GET\t/v1/browse/categories/{id}/playlists\tGet a category's playlists\tplaylists*\tOAuth\n# GET\t/v1/me\tGet current user's profile\tuser\tOAuth\n# GET\t/v1/me/following\tGet Followed Artists\tartists\tOAuth\n# PUT\t/v1/me/following\tFollow Artists or Users\t-\tOAuth\n# DELETE\t/v1/me/following\tUnfollow Artists or Users\t-\tOAuth\n# GET\t/v1/me/following/contains\tCheck if User Follows Users or Artists\ttrue/false\tOAuth\n# PUT\t/v1/users/{owner_id}/playlists/{playlist_id}/followers\tFollow a Playlist\t-\tOAuth\n# DELETE\t/v1/users/{owner_id}/playlists/{playlist_id}/followers\tUnfollow a Playlist\t-\tOAuth\n# PUT\t/v1/me/tracks?ids={ids}\n# Save tracks for user\t-\tOAuth\n# GET\n# /v1/me/tracks\n# Get user's saved tracks\tsaved tracks\tOAuth\n# DELETE\t/v1/me/tracks?ids={ids}\tRemove user's saved tracks\t-\tOAuth\n# GET\n# /v1/me/tracks/contains?ids={ids}\n# Check user's saved tracks\ttrue/false\tOAuth\n# PUT\t/v1/me/albums?ids={ids}\n# Save albums for user\t-\tOAuth\n# GET\n# /v1/me/albums\n# Get user's saved albums\tsaved albums\tOAuth\n# DELETE\t/v1/me/albums?ids={ids}\tRemove user's saved albums\t-\tOAuth\n# GET\n# /v1/me/albums/contains?ids={ids}\n# Check user's saved albums\ttrue/false\tOAuth\n# GET\t/v1/me/top/{type}\tGet a user's top artists or tracks\tartists or tracks\tOAuth\n# GET\t/v1/recommendations\tGet recommendations based on seeds\trecommendations object\tOAuth\n# GET\n# /v1/search?type=album\tSearch for an album\talbums*\tOAuth\n# GET\n# /v1/search?type=artist\n# Search for an artist\tartists\tOAuth\n# GET\t/v1/search?type=playlist\tSearch for a playlist\tplaylists*\tOAuth\n# GET\t/v1/search?type=track\tSearch for a track\ttracks\tOAuth\n# GET\n# /v1/tracks/{id}\n# Get a track\ttracks\tOAuth\n# GET\n# /v1/tracks?ids={ids}\n# Get several tracks\ttracks\tOAuth\n# GET\n# /v1/users/{user_id}\n# Get a user's profile\tuser*\tOAuth\n# GET\t/v1/users/{user_id}/playlists\tGet a list of a user's playlists\tplaylists*\tOAuth\n# GET\t/v1/me/playlists\tGet a list of the current user's playlists\tplaylists*\tOAuth\n# GET\t/v1/users/{user_id}/playlists/{playlist_id}\tGet a playlist\tplaylist\tOAuth\n# GET\t/v1/users/{user_id}/playlists/{playlist_id}/tracks\tGet a playlist's tracks\ttracks\tOAuth\n# POST\t/v1/users/{user_id}/playlists\tCreate a playlist\tplaylist\tOAuth\n# PUT\t/v1/users/{user_id}/playlists/{playlist_id}\tChange a playlist's details\t-\tOAuth\n# POST\t/v1/users/{user_id}/playlists/{playlist_id}/tracks\tAdd tracks to a playlist\t-\tOAuth\n# DELETE\t/v1/users/{user_id}/playlists/{playlist_id}/tracks\tRemove tracks from a playlist\tsnapshot_id\tOAuth\n# PUT\t/v1/users/{user_id}/playlists/{playlist_id}/tracks\tReorder a playlist's tracks\tsnapshot_id\tOAuth\n# PUT\t/v1/users/{user_id}/playlists/{playlist_id}/tracks\tReplace a playlist's tracks\t-\tOAuth\n# GET\t/v1/users/{user_id}/playlists/{playlist_id}/followers/contains\tCheck if Users Follow a Playlist\ttrue/false\tOAuth\n# GET\tv1/me/player/recently-played\tGet Current User’s Recently Played Tracks\tplay history object\tOAuth\n# GET\t/v1/me/player/devices\tGet a User’s Available Devices\t\tOAuth\n# GET\t/v1/me/player\tGet Information About The User’s Current Playback\t\tOAuth\n# GET\t/v1/me/player/currently-playing\tGet the User’s Currently Playing Track\t\tOAuth\n# PUT\t/v1/me/player\tTransfer a User’s Playback\t\tOAuth\n# PUT\t/v1/me/player/play\tStart/Resume a User’s Playback\t\tOAuth\n# PUT\t/v1/me/player/pause\tPause a User’s Playback\t\tOAuth\n# POST\t/v1/me/player/next\tSkip User’s Playback To Next Track\t\tOAuth\n# POST\t/v1/me/player/previous\tSkip User’s Playback To Previous Track\t\tOAuth\n# PUT\tv1/me/player/seek\tSeek To Position In Currently Playing Track\t\tOAuth\n# PUT\t/v1/me/player/repeat\tSet Repeat Mode On User’s Playback\t\tOAuth\n# PUT\t/v1/me/player/volume\tSet Volume For User’s Playback\t\tOAuth\n# PUT\t/v1/me/player/shuffle\tToggle Shuffle For User’s Playback\t\tOAuth",
    "created" : 1497341168368.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1384001433",
    "id" : "343B116E",
    "lastKnownWriteTime" : 1497386771,
    "last_content_update" : 1497386771500,
    "path" : "~/gfella/server.R",
    "project_path" : "server.R",
    "properties" : {
        "tempName" : "Untitled2"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}